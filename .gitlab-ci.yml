# GitLab CI/CD Pipeline for Robot API

stages:
  - build
  - test
  - deploy

variables:
  GO_VERSION: "1.21"
  DOCKER_IMAGE_NAME: "robot-api"
  DOCKER_IMAGE_TAG: "latest"
  # GitLab Container Registry for HSB
  DOCKER_REGISTRY: "registry.gitlab.com/hsbremen/mkss2/sose-2025/labor"
  # Azure Deployment Configuration
  AZURE_RESOURCE_GROUP: "robotApiGroup"
  AZURE_LOCATION: "westeurope"
  AZURE_CONTAINER_NAME: "robot-api-container"
  AZURE_DNS_LABEL: "robot-api-${CI_PROJECT_NAME}"

# BUILD STAGE: Compile Go application
build:
  stage: build
  image: golang:${GO_VERSION}-alpine
  before_script:
    - echo "üî® Building Robot API..."
    - go version
  script:
    - echo "üì¶ Downloading dependencies..."
    - go mod download
    - go mod verify
    - echo "üî® Building application..."
    - go build -o robot-api .
    - echo "‚úÖ Build completed successfully"
    - ls -la robot-api
  artifacts:
    paths:
      - robot-api
    expire_in: 1 hour
    reports:
      # For GitLab Reports
      junit: report.xml
  cache:
    key: go-mod-cache
    paths:
      - /go/pkg/mod/

# TEST STAGE: Execute unit tests
test:
  stage: test
  image: golang:${GO_VERSION}-alpine
  dependencies:
    - build
  before_script:
    - echo "üß™ Running unit tests..."
    - go version
  script:
    - echo "üì¶ Downloading dependencies for tests..."
    - go mod download
    - echo "üß™ Executing unit tests..."
    - go test -v -cover ./...
    - echo "‚úÖ All tests passed"
  coverage: '/coverage: \d+\.\d+% of statements/'
  cache:
    key: go-mod-cache
    paths:
      - /go/pkg/mod/
    policy: pull

# DEPLOY STAGE: Build Docker image and deploy to Azure
deploy:
  stage: deploy
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  dependencies:
    - build
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_DRIVER: overlay2
  before_script:
    - echo "üöÄ Starting deployment process..."

    # Install build dependencies and Azure CLI with virtual environment
    - apk add --no-cache python3 py3-pip bash curl wget jq gcc musl-dev python3-dev linux-headers
    - python3 -m venv /tmp/azure-venv
    - source /tmp/azure-venv/bin/activate
    - pip install --upgrade pip
    - pip install azure-cli

    # Docker Registry Login with better error handling
    - echo "üîê Logging into GitLab Container Registry..."
    - |
      if [ -z "$CI_REGISTRY_PASSWORD" ]; then
        echo "‚ùå ERROR: CI_REGISTRY_PASSWORD is not set"
        exit 1
      fi

      if [ -z "$CI_REGISTRY_USER" ]; then
        echo "‚ùå ERROR: CI_REGISTRY_USER is not set"
        exit 1
      fi

      echo "Attempting to login to $CI_REGISTRY as $CI_REGISTRY_USER"
      echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY || {
        echo "‚ùå Docker login failed. Checking if we can use project-level registry..."
        # Try with project-specific path
        echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin registry.gitlab.com
      }

    # Azure Login
    - echo "üîê Logging into Azure..."
    - az login --service-principal -u "$AZURE_SP_ID" -p "$AZURE_SP_PASSWORD" --tenant "$AZURE_TENANT_ID"
    - az account show

  script:
    # Activate virtual environment for script execution
    - source /tmp/azure-venv/bin/activate

    # Use project path for better compatibility
    - export FULL_IMAGE_NAME="$DOCKER_REGISTRY/$CI_PROJECT_PATH/$DOCKER_IMAGE_NAME:$DOCKER_IMAGE_TAG"

    # Build Docker image
    - docker build -t $FULL_IMAGE_NAME .
    - echo "‚úÖ Docker image built successfully"

    # List images for debugging
    - docker images | grep robot-api || echo "No robot-api images found"

    # Push image to registry
    - echo "üì§ Pushing image to GitLab Container Registry..."
    - docker push $FULL_IMAGE_NAME
    - echo "‚úÖ Image pushed successfully"

    # Prepare Azure infrastructure
    - echo "‚òÅÔ∏è Preparing Azure infrastructure..."
    - az group create --name $AZURE_RESOURCE_GROUP --location $AZURE_LOCATION || true
    - az provider register --namespace Microsoft.ContainerInstance || true

    # Wait for provider registration
    - |
      echo "‚è≥ Waiting for Azure Container Instance provider registration..."
      for i in {1..30}; do
        STATUS=$(az provider show --namespace Microsoft.ContainerInstance --query registrationState -o tsv)
        echo "Registration status: $STATUS (attempt $i/30)"
        if [ "$STATUS" = "Registered" ]; then
          echo "‚úÖ Provider registered successfully"
          break
        fi
        sleep 10
      done

    # Clean up existing container if present
    - echo "üßπ Cleaning up existing container..."
    - az container delete --resource-group $AZURE_RESOURCE_GROUP --name $AZURE_CONTAINER_NAME --yes || true
    - sleep 15

    # Deploy new container
    - echo "üöÄ Deploying to Azure Container Instances..."
    - |
      az container create \
        --resource-group $AZURE_RESOURCE_GROUP \
        --name $AZURE_CONTAINER_NAME \
        --image $FULL_IMAGE_NAME \
        --dns-name-label $AZURE_DNS_LABEL \
        --ports 8080 \
        --registry-login-server $CI_REGISTRY \
        --registry-username $CI_REGISTRY_USER \
        --registry-password $CI_REGISTRY_PASSWORD \
        --os-type Linux \
        --cpu 1 \
        --memory 1.5 \
        --environment-variables PORT=8080 GIN_MODE=release \
        --restart-policy OnFailure

    # Verify deployment
    - echo "‚è≥ Waiting for container to start..."
    - sleep 45

    # Check container status
    - echo "üîç Checking container status..."
    - az container show --resource-group $AZURE_RESOURCE_GROUP --name $AZURE_CONTAINER_NAME --query provisioningState -o tsv

    # Get FQDN
    - |
      FQDN=$(az container show --resource-group $AZURE_RESOURCE_GROUP --name $AZURE_CONTAINER_NAME --query ipAddress.fqdn -o tsv)
      echo "üåê Container FQDN: $FQDN"

    # Perform API tests
    - echo "üß™ Testing deployed API..."

    # Health Check with retry
    - echo "Testing health endpoint..."
    - |
      for i in {1..10}; do
        echo "Health check attempt $i/10..."
        if curl -f --connect-timeout 10 --max-time 30 "http://$FQDN:8080/health"; then
          echo "‚úÖ Health check passed"
          break
        else
          echo "‚ùå Health check attempt $i failed, retrying in 15 seconds..."
          sleep 15
        fi
      done

    # API Endpoint Tests
    - echo "Testing API endpoints..."
    - curl -f --max-time 10 "http://$FQDN:8080/" || echo "‚ö†Ô∏è Root endpoint check failed"
    - curl -f --max-time 10 "http://$FQDN:8080/items" || echo "‚ö†Ô∏è Items endpoint check failed"
    - curl -f --max-time 10 "http://$FQDN:8080/robot/robot1/status" || echo "‚ö†Ô∏è Robot status check failed"

    # Functional test: Robot Movement
    - |
      echo "Testing robot movement..."
      curl -f --max-time 10 -X POST "http://$FQDN:8080/robot/robot1/move" \
        -H "Content-Type: application/json" \
        -d '{"direction": "up"}' || echo "‚ö†Ô∏è Robot movement test failed"

    # Report deployment success
    - echo ""
    - echo "üéâ Deployment successful!"
    - echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

  # Only deploy on main/master branch
  only:
    - main
    - master

  # Manual trigger for deployment
  when: manual
  allow_failure: false

# Cleanup Job (optional, manual)
cleanup:
  stage: deploy
  image: alpine:latest
  variables:
    GIT_STRATEGY: none
  before_script:
    - apk add --no-cache python3 py3-pip gcc musl-dev python3-dev linux-headers
    - python3 -m venv /tmp/azure-venv
    - source /tmp/azure-venv/bin/activate
    - pip install --upgrade pip
    - pip install azure-cli
    - az login --service-principal -u "$AZURE_SP_ID" -p "$AZURE_SP_PASSWORD" --tenant "$AZURE_TENANT_ID"
  script:
    - source /tmp/azure-venv/bin/activate
    - echo "üßπ Cleaning up Azure resources..."
    - az container delete --resource-group $AZURE_RESOURCE_GROUP --name $AZURE_CONTAINER_NAME --yes || true
    - echo "‚úÖ Cleanup completed"
  when: manual
  only:
    - main
    - master
